

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1.1. 编程语言中的线程对象 &mdash; 运维开发修炼之路</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'1.0.0',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: ''
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="next" title="1.2. RabbitMQ" href="02.Rabbitmq分布式消息服务.html" />
    <link rel="prev" title="1. 分布式系统基础知识" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> 小健_Java_Blog
          

          
            
            <img src="../../_static/my_java_study.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../Java/index.html">Java学习笔记</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">分布式系统架构案例(Java)</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">1. 分布式系统基础知识</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">1.1. 编程语言中的线程对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">1.1.1. 定义和启动一个线程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">1.1.2. 方式1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">1.1.3. 方式2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sleep">1.1.4. 使用sleep来暂停执行</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">1.1.5. 中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simplethreads">1.1.6. SimpleThreads示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">1.1.7. 通信</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rpc">1.1.8. 远程过程调用RPC</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="02.Rabbitmq分布式消息服务.html">1.2. RabbitMQ</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">小健_Java_Blog</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">分布式系统架构案例(Java)</a> &raquo;</li>
        
          <li><a href="index.html">1. 分布式系统基础知识</a> &raquo;</li>
        
      <li>1.1. 编程语言中的线程对象</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/Distributed_Systems/01.分布式系统基础知识/01.编程语言中的线程对象.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id7">编程语言中的线程对象</a><ul>
<li><a class="reference internal" href="#id2" id="id8">定义和启动一个线程</a></li>
<li><a class="reference internal" href="#id3" id="id9">方式1</a></li>
<li><a class="reference internal" href="#id4" id="id10">方式2</a></li>
<li><a class="reference internal" href="#sleep" id="id11">使用sleep来暂停执行</a></li>
<li><a class="reference internal" href="#id5" id="id12">中断</a></li>
<li><a class="reference internal" href="#simplethreads" id="id13">SimpleThreads示例</a></li>
<li><a class="reference internal" href="#id6" id="id14">通信</a></li>
<li><a class="reference internal" href="#rpc" id="id15">远程过程调用RPC</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id7">1.1. 编程语言中的线程对象</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id8">1.1.1. 定义和启动一个线程</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Java中两种创建Thread实例的方式</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">1.1.2. 方式1</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>第一种,提供Runnable对象</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">thread</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">HelloRunnable</span> <span class="n">implements</span> <span class="n">Runnable</span> <span class="p">{</span>
    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;HeLLO FROM RUNNABLE`~~!!&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">new</span> <span class="n">Thread</span><span class="p">(</span><span class="n">new</span> <span class="n">HelloRunnable</span><span class="p">()))</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span>    <span class="n">Hello</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">runnable</span><span class="o">......</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id10">1.1.3. 方式2</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>第二种，继承Thread</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">thread</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">HelloRunnable2</span> <span class="n">extends</span> <span class="n">Thread</span> <span class="p">{</span>
    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Hello from a thread!&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">new</span> <span class="n">HelloRunnable2</span><span class="p">())</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sleep">
<h2><a class="toc-backref" href="#id11">1.1.4. 使用sleep来暂停执行</a><a class="headerlink" href="#sleep" title="Permalink to this headline">¶</a></h2>
<div class="code java highlight-default"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">thread</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">SleepMessages</span> <span class="p">{</span>
    <span class="o">/**</span>
     <span class="o">*</span> <span class="nd">@param</span> <span class="n">args</span>
     <span class="o">*</span> <span class="nd">@throws</span> <span class="n">InterruptedException</span>
     <span class="o">*/</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="n">throws</span> <span class="n">InterruptedException</span> <span class="p">{</span>
        <span class="n">String</span> <span class="n">importantInfo</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;Mares eat oats&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Does eat oats&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Little lambs eat ivy&quot;</span><span class="p">,</span>
                <span class="s2">&quot;A kid will eat ivy too&quot;</span><span class="p">};</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">importantInfo</span><span class="o">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">//</span> <span class="n">Pause</span> <span class="k">for</span> <span class="mi">4</span> <span class="n">seconds</span>
            <span class="n">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span>

            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">importantInfo</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>在main中声明抛出InterruptedException,若有另外一个线程中断当前线程时，则sleep抛出异常。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id12">1.1.5. 中断</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>支持中断</p>
<p>当线程被另一个线程中断的时候，捕捉异常，结束后续操作。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>public class SleepMessage2 {
    /**
     * @param args
     */

    public static void main(String[] args) throws InterruptedException{
        String importinfo[] = {
                &quot;hello hu1&quot;,
                &quot;hello hu2&quot;,
                &quot;hello hu3&quot;,
                &quot;hello hu4  ha ha ha ha&quot;,
        };
        for (int i = 0; i &lt;importinfo.length ; i++) {
            //暂停4s
            try {
                Thread.sleep(4000);
            } catch (InterruptedException e) {
                //已经中断，无需更多信息
                return;
            }
            System.out.println(importinfo[i]);
        }
    }
}
</pre></div>
</div>
</div>
<div class="section" id="simplethreads">
<h2><a class="toc-backref" href="#id13">1.1.6. SimpleThreads示例</a><a class="headerlink" href="#simplethreads" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span>/**
 * SimpleThreads 示例有两个线程。第一个线程是每个 Java 应用程序都有的主线程。
 * 主线程创建的Runnable 对象的MessageLoop，并等待它完成。如果 MessageLoop
 * 需要很长时间才能完成，主线程就中断它。
 *
 * @author &lt;a href=&quot;http://www.waylau.com&quot;&gt;waylau.com&lt;/a&gt;
 * @date 2016年1月21日
 */
public class SimpleThreads {
    // Display a message, preceded by
    // the name of the current thread
    static void threadMessage(String message) {
        String threadName = Thread.currentThread().getName();
        System.out.format(&quot;%s: %s%n&quot;, threadName, message);
    }

    /**
     * 遍历打印子进程名称和传入信息
     */
    private static class MessageLoop implements Runnable {
        public void run() {
            String importantInfo[] = {
                    &quot;Mares eat oats&quot;,
                    &quot;Does eat oats&quot;,
                    &quot;Little lambs eat ivy&quot;,
                    &quot;A kid will eat ivy too&quot;
            };
            try {
                for (int i = 0; i &lt; importantInfo.length; i++) {
                    // Pause for 4 seconds
                    Thread.sleep(4000);
                    // Print a message
                    threadMessage(importantInfo[i]);
                }
            } catch (InterruptedException e) {
                threadMessage(&quot;I wasn&#39;t done!&quot;);
            }
        }
    }

    public static void main(String args[])
            throws InterruptedException {

        // Delay, in milliseconds before
        // we interrupt MessageLoop
        // thread (default one hour).
        long patience = 1000 * 60 * 60;

        // If command line argument
        // present, gives patience
        // in seconds.
        if (args.length &gt; 0) {
            try {
                patience = Long.parseLong(args[0]) * 1000;
            } catch (NumberFormatException e) {
                System.err.println(&quot;Argument must be an integer.&quot;);
                System.exit(1);
            }
        }

        threadMessage(&quot;Starting MessageLoop thread&quot;);
        long startTime = System.currentTimeMillis();
        Thread t = new Thread(new MessageLoop());
        t.start();

        threadMessage(&quot;Waiting for MessageLoop thread to finish&quot;);
        // loop until MessageLoop
        // thread exits
        while (t.isAlive()) {
            threadMessage(&quot;Still waiting...&quot;);
            // Wait maximum of 1 second
            // for MessageLoop thread
            // to finish.
            t.join(1000);
            // 如果时间间隔s数 大于1个小时并且子进程还是活着的状态，就中断掉
            if (((System.currentTimeMillis() - startTime) &gt; patience) &amp;&amp; t.isAlive()) {
                threadMessage(&quot;Tired of waiting!&quot;);
                t.interrupt();
                // Shouldn&#39;t be long now
                // -- wait indefinitely
                t.join();   //否则主进程就必须一直等待子进程完成
            }
        }
        threadMessage(&quot;Finally!&quot;);
    }
}
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id14">1.1.7. 通信</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p><strong>网络IO模型的演讲</strong> 1.同步和异步</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>同步是指用户线程发起I/O请求后需要等待或者轮询内核I/O操作完成后才能继续执行。

异步是指用户发起I/O请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户进程的回调函数。
</pre></div>
</div>
<p>2.阻塞和非阻塞 阻塞和非阻塞描述的是用户线程调用I/O操作的方式：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>· 阻塞是指I/O操作要彻底完成后才返回到用户空间。
· 非阻塞是指I/O操作被调用后，立刻返回给用户一个状态值，无需等到I/O操作彻底完成。
</pre></div>
</div>
<p><strong>常见的Java I/O模型</strong> 单进程阻塞I/O模式，server
监听7端口，只能有一个客户端连接</p>
<p>EchoServer.java</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * “阻塞I/O”模式
 *
 * @author &lt;a href=&quot;https://waylau.com&quot;&gt;waylau.com&lt;/a&gt;
 * @date 2016年7月29日
 */
public class EchoServer {
    public static int DEFAULT_PORT = 7;

    public static void main(String[] args) throws IOException {

        int port;

        try {
            port = Integer.parseInt(args[0]);
        } catch (RuntimeException ex) {
            port = DEFAULT_PORT;
        }

        try (
                ServerSocket serverSocket =
                        new ServerSocket(port);

                Socket clientSocket = serverSocket.accept();
                PrintWriter out =
                        new PrintWriter(clientSocket.getOutputStream(), true);
                BufferedReader in = new BufferedReader(
                        new InputStreamReader(clientSocket.getInputStream()));
        ) {
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                out.println(inputLine);
//                System.out.println(inputLine);
            }
        } catch (IOException e) {
            System.out.println(&quot;Exception caught when trying to listen&quot;
                    + &quot; on port &quot; + port
                    + &quot; or listening for a connection&quot;);
            System.out.println(e.getMessage());
        }
    }

}
</pre></div>
</div>
<p><strong>阻塞I/O + 多线程模式</strong></p>
<p>存在问题，每次接到新的连接要新建一个线程，处理完销毁线程，代价大。性能比较低。</p>
<p><code class="docutils literal"><span class="pre">EchoServerHandler.java</span></code></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintWriter</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="p">;</span>

<span class="o">/**</span>
 <span class="o">*</span> <span class="n">处理器类</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="nd">@author</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;https://waylau.com&quot;</span><span class="o">&gt;</span><span class="n">waylau</span><span class="o">.</span><span class="n">com</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
 <span class="o">*</span> <span class="nd">@date</span> <span class="mi">2016</span><span class="n">年7月29日</span>
 <span class="o">*/</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">EchoServerHandler</span> <span class="n">implements</span> <span class="n">Runnable</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">Socket</span> <span class="n">clientSocket</span><span class="p">;</span>

    <span class="n">public</span> <span class="n">EchoServerHandler</span><span class="p">(</span><span class="n">Socket</span> <span class="n">clientSocket</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">clientSocket</span> <span class="o">=</span> <span class="n">clientSocket</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">(</span>
                <span class="n">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="n">new</span> <span class="n">PrintWriter</span><span class="p">(</span><span class="n">clientSocket</span><span class="o">.</span><span class="n">getOutputStream</span><span class="p">()</span>
                        <span class="p">,</span> <span class="n">true</span><span class="p">);</span>
                <span class="n">BufferedReader</span> <span class="ow">in</span> <span class="o">=</span> <span class="n">new</span> <span class="n">BufferedReader</span><span class="p">(</span>
                        <span class="n">new</span> <span class="n">InputStreamReader</span><span class="p">(</span><span class="n">clientSocket</span><span class="o">.</span><span class="n">getInputStream</span><span class="p">()));)</span> <span class="p">{</span>

            <span class="n">String</span> <span class="n">inputLine</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">((</span><span class="n">inputLine</span> <span class="o">=</span> <span class="ow">in</span><span class="o">.</span><span class="n">readLine</span><span class="p">())</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">inputLine</span><span class="p">);</span>
                <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">inputLine</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">getMessage</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>MultiThreadEchoServer.java</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * “阻塞I/O+多线程”模式。使用多线程来支持多个客户端访问服务器
 *
 * @author &lt;a href=&quot;https://waylau.com&quot;&gt;waylau.com&lt;/a&gt;
 * @date 2016年7月29日
 */
public class MultiThreadEchoServer {
    public static int DEFAULT_PORT = 7;

    public static void main(String[] args) throws IOException {

        int port;

        try {
            port = Integer.parseInt(args[0]);
        } catch (RuntimeException ex) {
            port = DEFAULT_PORT;
        }
        Socket clientSocket = null;
        try (ServerSocket serverSocket = new ServerSocket(port);) {
            while (true) {
                clientSocket = serverSocket.accept();

                // 多线程
                new Thread(new EchoServerHandler(clientSocket)).start();
            }
        } catch (IOException e) {
            System.out.println(
                    &quot;Exception caught when trying to listen on port &quot;
                            + port + &quot; or listening for a connection&quot;);
            System.out.println(e.getMessage());
        }
    }
}
</pre></div>
</div>
<p><strong>阻塞I/O+线程池模式</strong></p>
<p>优点：在大量短连接场景中，性能会有所提升，因为复用线程池中的线程，不用频繁的创建和销毁线程，在长连接场景中，因为线程一直长期占有。
并无显著的效果优势。
适用于小或者中的客户端连接数，如果连接数超过100000或者更多，那么性能将很不理想。</p>
<p><strong>非阻塞I/O模式</strong> NonBlokingEchoServer.java</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

/**
 * “非阻塞I/O”模式
 *
 * @author &lt;a href=&quot;https://waylau.com&quot;&gt;waylau.com&lt;/a&gt;
 * @date 2016年7月29日
 */
public class NonBlokingEchoServer {

    public static int DEFAULT_PORT = 7;

    public static void main(String[] args) throws IOException {

        int port;

        try {
            port = Integer.parseInt(args[0]);
        } catch (RuntimeException ex) {
            port = DEFAULT_PORT;
        }
        System.out.println(&quot;Listening for connections on port &quot; + port);

        ServerSocketChannel serverChannel;
        Selector selector;
        try {
            serverChannel = ServerSocketChannel.open();
            InetSocketAddress address = new InetSocketAddress(port);
            serverChannel.bind(address);
            serverChannel.configureBlocking(false);
            selector = Selector.open();
            serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        } catch (IOException ex) {
            ex.printStackTrace();
            return;
        }

        while (true) {
            try {
                selector.select();
            } catch (IOException ex) {
                ex.printStackTrace();
                break;
            }
            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();
            while (iterator.hasNext()) {
                SelectionKey key = iterator.next();
                iterator.remove();
                try {
                    if (key.isAcceptable()) {
                        ServerSocketChannel server = (ServerSocketChannel) key.channel();
                        SocketChannel client = server.accept();
                        System.out.println(&quot;Accepted connection from &quot; + client);
                        client.configureBlocking(false);
                        SelectionKey clientKey = client.register(selector,
                                SelectionKey.OP_WRITE | SelectionKey.OP_READ);
                        ByteBuffer buffer = ByteBuffer.allocate(100);
                        clientKey.attach(buffer);
                    }
                    if (key.isReadable()) {
                        SocketChannel client = (SocketChannel) key.channel();
                        ByteBuffer output = (ByteBuffer) key.attachment();
                        client.read(output);
                    }
                    if (key.isWritable()) {
                        SocketChannel client = (SocketChannel) key.channel();
                        ByteBuffer output = (ByteBuffer) key.attachment();
                        output.flip();
                        client.write(output);

                        output.compact();
                    }
                } catch (IOException ex) {
                    key.cancel();
                    try {
                        key.channel().close();
                    } catch (IOException cex) {
                    }
                }
            }
        }

    }
}
</pre></div>
</div>
<p><strong>异步I/O模式</strong> 省略</p>
</div>
<div class="section" id="rpc">
<h2><a class="toc-backref" href="#id15">1.1.8. 远程过程调用RPC</a><a class="headerlink" href="#rpc" title="Permalink to this headline">¶</a></h2>
<p>C/S模型和过程调用时，需要考虑</p>
<p>过程调用的类型</p>
<p>· 本地的过程调用</p>
<p>· 同主机的过程调用</p>
<p>· 不同主机的过程调用</p>
<p>市面上的RPC开源软件很多，可以搜索并研究使用方式。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="02.Rabbitmq分布式消息服务.html" class="btn btn-neutral float-right" title="1.2. RabbitMQ" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="1. 分布式系统基础知识" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, huxiaojian

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>